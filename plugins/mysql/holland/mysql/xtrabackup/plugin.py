"""
holland.mysql.xtrabackup.plugin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Xtrabackup plugin for holland

"""

import contextlib
import logging
import os
import subprocess
import sys

from holland.core.backup.plugin import BackupPlugin
from holland.core.util.path import directory_size
from holland.core.stream.interface import open_stream, load_stream_plugin
from holland.mysql.client import MySQL, generate_defaults_file
from holland.mysql.xtrabackup import util

LOG = logging.getLogger(__name__)

class XtrabackupPlugin(BackupPlugin):
    #: control connection to mysql server
    mysql = None

    #: path to the my.cnf generated by this plugin
    defaults_path = None

    def setup(self):
        defaults_path = os.path.join(self.backup_directory, 'my.cnf')
        client_opts = self.config['mysql:client']
        includes = [self.config['xtrabackup']['global-defaults']] + \
                   client_opts['defaults-extra-file']
        generate_defaults_file(defaults_path, includes, **client_opts)
        self.defaults_path = defaults_path


    def estimate(self):
        try:
            client = MySQL.from_defaults(self.defaults_path)
        except MySQL.MySQLError as exc:
            raise BackupError('Failed to connect to MySQL [%d] %s' % exc.args)

        try:
            try:
                 datadir = client.var('datadir')
            except MySQL.DatabaseError as exc:
                raise BackupError("Failed to find mysql datadir: [%d] %s" %
                                  exc.orig.args)

            try:
                return directory_size(datadir)
            except OSError as exc:
                raise BackupError('Failed to calculate directory size: [%d] %s'
                                  % (exc.errno, exc.strerror))
        finally:
            client.dispose()

    @contextlib.contextmanager
    def open_xb_logfile(self):
        """Open a file object to the log output for xtrabackup"""
        path = os.path.join(self.backup_directory, 'xtrabackup.log')
        try:
            with open(path, 'ab') as fileobj:
                yield fileobj
        except IOError as exc:
            raise BackupError('[%d] %s' % (exc.errno, exc.strerror))

    @contextlib.contextmanager
    def open_xb_stdout(self):
        """Open the stdout output for a streaming xtrabackup run"""
        config = self.config.xtrabackup
        backup_directory = self.backup_directory
        stream = util.determine_stream_method(config['stream'])
        if stream:
            compression = load_stream_plugin(self.config.compression)
            if stream == 'tar':
                archive_path = os.path.join(backup_directory, 'backup.tar')
            elif stream == 'xbstream':
                archive_path = os.path.join(backup_directory, 'backup.xb')
            else:
                raise BackupError("Unknown stream method '%s'" % stream)
            try:
                with compression.open(archive_path, 'wb') as fileobj:
                    yield fileobj
            except OSError as exc:
                raise BackupError("Unable to create output file: %s" % exc)
        else:
            with open('/dev/null', 'wb') as fileobj:
                yield fileobj


    def dryrun(self):
        xb_cfg = self.config['xtrabackup']
        args = util.build_xb_args(xb_cfg, self.backup_directory,
                self.defaults_path)
        LOG.info("* xtrabackup command: %s", list2cmdline(args))
        args = [
            'xtrabackup',
            '--defaults-file=' + self.defaults_path,
            '--help'
        ]
        cmdline = list2cmdline(args)
        LOG.info("* Verifying generated config '%s'", self.defaults_path)
        LOG.debug("* Verifying via command: %s", cmdline)
        try:
            process = Popen(args, stdout=PIPE, stderr=STDOUT, close_fds=True)
        except OSError as exc:
            raise BackupError("%s failed: [%d] %s" % (
                               args[0], exc.errno, exc.strerror))

        stdout, _ = process.communicate()
        # Note: xtrabackup --help will exit with 1 usually
        if process.returncode != 1:
            LOG.error("! %s failed. Output follows below.", cmdline)
            for line in stdout.splitlines():
                LOG.error("! %s", line)
            raise BackupError("%s exited with failure status [%d]" %
                              (cmdline, process.returncode))

    def backup(self):
        xb_cfg = self.config['xtrabackup']
        backup_directory = self.backup_directory
        tmpdir = util.evaluate_tmpdir(xb_cfg['tmpdir'], backup_directory)
        # innobackupex --tmpdir does not affect xtrabackup
        util.add_xtrabackup_defaults(self.defaults_path, tmpdir=tmpdir)
        args = util.build_xb_args(xb_cfg, backup_directory, self.defaults_path)
        util.execute_pre_command(xb_cfg['pre-command'],
                                 backup_directory=backup_directory)
        with self.open_xb_logfile() as stderr:
            with self.open_xb_stdout() as stdout:
                try:
                    util.run_xtrabackup(args, stdout, stderr)
                except Exception as exc:
                    LOG.info("!! %s", exc)
                    for line in open(join(self.backup_directory, 'xtrabackup.log'), 'r'):
                        LOG.error("    ! %s", line.rstrip())
                    raise

        if xb_cfg['apply-logs']:
            util.apply_xtrabackup_logfile(xb_cfg, args[-1])
